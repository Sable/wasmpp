{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wasm++ Wasm++ is a C++ library that allow developers to write WebAssembly programs by building WABT IR objects. Getting Started Makers Generators Managers Example of Usage WasmDNN","title":"Home"},{"location":"#wasm","text":"Wasm++ is a C++ library that allow developers to write WebAssembly programs by building WABT IR objects.","title":"Wasm++"},{"location":"#getting-started","text":"Makers Generators Managers","title":"Getting Started"},{"location":"#example-of-usage","text":"WasmDNN","title":"Example of Usage"},{"location":"maker_generator/","text":"Maker Generator Functions A maker function simply creates an atomic functionality such as binary operation, unary operation, load from memory, store to memory and many others. Maker functions are prefixed with the word \"Make\". Example Wasm++ MakeBinary(Opcpde::I32Add, MakeI32Const(1), MakeI32Const(2)); WebAssembly (Wat) i32.const 1 i32.const 2 i32.add Generator functions are a little more complicated as they build on top of makers to create more complex semantic. Generator functions are prefixed with the word \"Generate\". Example Below is an example of a generator for building a for loop ranging from i=0 to 100 while incrementing by 1. Wasm++ // param 1: Label manager pointer // param 2: Local variables // param 3: Range from // param 4: Range to // param 5: Increment value // param 6: Loop return value // param 7: Body code of the loop GenerateRangeLoop(label_manager, i, 0, 100, 1, {}, [ ](BlockBody* body) { // Loop body: e.g. body- Insert(MakeCall(...)); }); WebAssembly (Wat) i32.const 0 set_local $i loop $loop_1 // Loop body ... get_local $i i32.const 1 i32.add tee_local $i i32.const 100 i32.ne br_if $loop_1 end","title":"Makers & Generators"},{"location":"maker_generator/#maker-generator-functions","text":"A maker function simply creates an atomic functionality such as binary operation, unary operation, load from memory, store to memory and many others. Maker functions are prefixed with the word \"Make\".","title":"Maker &amp; Generator Functions"},{"location":"maker_generator/#example","text":"","title":"Example"},{"location":"maker_generator/#wasm","text":"MakeBinary(Opcpde::I32Add, MakeI32Const(1), MakeI32Const(2));","title":"Wasm++"},{"location":"maker_generator/#webassembly-wat","text":"i32.const 1 i32.const 2 i32.add Generator functions are a little more complicated as they build on top of makers to create more complex semantic. Generator functions are prefixed with the word \"Generate\".","title":"WebAssembly (Wat)"},{"location":"maker_generator/#example_1","text":"Below is an example of a generator for building a for loop ranging from i=0 to 100 while incrementing by 1.","title":"Example"},{"location":"maker_generator/#wasm_1","text":"// param 1: Label manager pointer // param 2: Local variables // param 3: Range from // param 4: Range to // param 5: Increment value // param 6: Loop return value // param 7: Body code of the loop GenerateRangeLoop(label_manager, i, 0, 100, 1, {}, [ ](BlockBody* body) { // Loop body: e.g. body- Insert(MakeCall(...)); });","title":"Wasm++"},{"location":"maker_generator/#webassembly-wat_1","text":"i32.const 0 set_local $i loop $loop_1 // Loop body ... get_local $i i32.const 1 i32.add tee_local $i i32.const 100 i32.ne br_if $loop_1 end","title":"WebAssembly (Wat)"},{"location":"managers/","text":"Managers Label Manager Names generated for Wasm instructions are assigned by the label manager. The latter simply creates a unique identifier on each request. Memory Manager Memory manager in Wasm++ uses a first fit approach to allocate linear memory space. The memory manager operates at Wasm-generation time. Thus, addresses can directly be injected inside functions as i32 values. Furthermore, the manager can automatically compute the amount of linear memory pages, of size 64KB each, required by a program. Example C++ wasmpp::MemoryManager* mm = new wasmpp::FirstFit(); wasmpp::Memory* name = mm- Allocate(50); // Allocate 50 bytes to store name string wasmpp::Memory* age = mm- Allocate(1); // Allocate 1 byte to store age printf( Begin address: %d\\tEnd address: %d\\tSize: %d\\n , name- Begin(), name- End(), name- Bytes()); printf( Begin address: %d\\tEnd address: %d\\tSize: %d\\n , age- Begin(), age- End(), age- Bytes()); mm- Free(name); mm- Free(age); delete mm; Output Begin address: 0 End address: 50 Size: 50 Begin address: 50 End address: 51 Size: 1 Module Manager A module manager is the container of the memory and label managers, and hosts all the Wasm functions and other sections living on the global scope of a module. This manager also uses functionalities provided by the WABT library such as compiling the IR to WebAssembly bytecode or to Wat format, and validating the correctness of the generated WebAssembly. Example C++ using namespace std; using namespace wabt; using namespace wasmpp; int main() { // Create a Wasm module ModuleManager module; // Create a function that loads the value of // an i32 address, that is passed as an argument, // from the linear memory TypeVector params = {Type::I32}; TypeVector returns = {Type::I32}; TypeVector locals = {}; module.MakeFunction( load_example , {params, returns}, locals, [ ](FuncBody f, vector Var params, std::vector Var locals) { auto memory_load = MakeI32Load(MakeLocalGet(params[0])); f.Insert(memory_load); }); // Create memory section uint32_t memory_pages = module.Memory().Pages(); module.MakeMemory(memory_pages); // Validate and generate Wat assert(module.Validate()); bool folded = false; bool inline_import_export = true; printf( %s\\n , module.ToWat(folded, inline_import_export).c_str()); return 0; } Output (module (type (;0;) (func (param i32) (result i32))) (func $0 (export load_example ) (param $1 i32) (result i32) local.get 0 i32.load) (memory $2 0))","title":"Managers"},{"location":"managers/#managers","text":"","title":"Managers"},{"location":"managers/#label-manager","text":"Names generated for Wasm instructions are assigned by the label manager. The latter simply creates a unique identifier on each request.","title":"Label Manager"},{"location":"managers/#memory-manager","text":"Memory manager in Wasm++ uses a first fit approach to allocate linear memory space. The memory manager operates at Wasm-generation time. Thus, addresses can directly be injected inside functions as i32 values. Furthermore, the manager can automatically compute the amount of linear memory pages, of size 64KB each, required by a program.","title":"Memory Manager"},{"location":"managers/#example","text":"","title":"Example"},{"location":"managers/#c","text":"wasmpp::MemoryManager* mm = new wasmpp::FirstFit(); wasmpp::Memory* name = mm- Allocate(50); // Allocate 50 bytes to store name string wasmpp::Memory* age = mm- Allocate(1); // Allocate 1 byte to store age printf( Begin address: %d\\tEnd address: %d\\tSize: %d\\n , name- Begin(), name- End(), name- Bytes()); printf( Begin address: %d\\tEnd address: %d\\tSize: %d\\n , age- Begin(), age- End(), age- Bytes()); mm- Free(name); mm- Free(age); delete mm;","title":"C++"},{"location":"managers/#output","text":"Begin address: 0 End address: 50 Size: 50 Begin address: 50 End address: 51 Size: 1","title":"Output"},{"location":"managers/#module-manager","text":"A module manager is the container of the memory and label managers, and hosts all the Wasm functions and other sections living on the global scope of a module. This manager also uses functionalities provided by the WABT library such as compiling the IR to WebAssembly bytecode or to Wat format, and validating the correctness of the generated WebAssembly.","title":"Module Manager"},{"location":"managers/#example_1","text":"","title":"Example"},{"location":"managers/#c_1","text":"using namespace std; using namespace wabt; using namespace wasmpp; int main() { // Create a Wasm module ModuleManager module; // Create a function that loads the value of // an i32 address, that is passed as an argument, // from the linear memory TypeVector params = {Type::I32}; TypeVector returns = {Type::I32}; TypeVector locals = {}; module.MakeFunction( load_example , {params, returns}, locals, [ ](FuncBody f, vector Var params, std::vector Var locals) { auto memory_load = MakeI32Load(MakeLocalGet(params[0])); f.Insert(memory_load); }); // Create memory section uint32_t memory_pages = module.Memory().Pages(); module.MakeMemory(memory_pages); // Validate and generate Wat assert(module.Validate()); bool folded = false; bool inline_import_export = true; printf( %s\\n , module.ToWat(folded, inline_import_export).c_str()); return 0; }","title":"C++"},{"location":"managers/#output_1","text":"(module (type (;0;) (func (param i32) (result i32))) (func $0 (export load_example ) (param $1 i32) (result i32) local.get 0 i32.load) (memory $2 0))","title":"Output"}]}